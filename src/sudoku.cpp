#include "sudoku.hpp"
#include "classic_board.hpp"

namespace wills::sudoku
{
    bool sudoku::load_cells(std::vector<sudoku_cell_t> cell_array)
    {
        std::shared_ptr<classic_board> pb = std::make_shared<classic_board>();
        /*load data code
        */
        pb->read(cell_array);
        board = pb;
        return false;
    }

    void sudoku::add_rule(std::shared_ptr<rule> rule)
    {
        rule->attach(board);
        rules.push_back(rule);
    }

    std::vector<classic_board> sudoku::solve()
    {
        std::vector<classic_board> result;
        size_t total_col = 0;
        for(auto rule:rules){
            if(!rule->parse()){
                std::cerr << rule->getname() << " can't parse sudoku board." << std::endl;
                return result;
            }
            else total_col += rule->dlx_cols();
        }

        dlx::dancing_links<sudoku_cell_t> dlx;
        dlx.init_cols(total_col);
        /*
        //TODO: implement this, need row data compress function
            one row has multi row data generated by different rules, each rules col start with 0
            must be a function to compress it 
        */
        // 
        std::vector<row_t<sudoku_cell_t>> rows;
        for(auto rule:rules){
            // rows.push_back(rule->generate_dlx_row();
        }

        for(const auto & row:rows)dlx.append_row(row);
        auto rslts = dlx.solve_once();

        return result;
    }
} // namespace wills::sudoku